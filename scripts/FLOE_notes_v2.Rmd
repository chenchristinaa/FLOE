---
title: "FLOE_notes"
author: "Christina Chen"
date: "2024-03-01"
output: html_document
---

# Week 1

## Set Up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries}
library(tidyverse)
library(devtools)
library(edgeR)
library(shiny)
```

```{r read files}
sdiv <- read_tsv("../input/Christina_HiFi_Sdiv_Gene_Counts.tsv")
sample <- read_csv("../input/Hydrothermal_Round_1_Sample_Descriptions.csv")
```

## Environment Information

- sdiv = counts tsv file that was given
- sample = sample cvs file that was given
- dry_sample = sample csv with only dry condition, and without i02 and i03
- dry_sdiv = counts tsv with only dry condition
- dge_data = DGEList and calcNormFactors
- normal_dry_sdiv = cpm of dge_data
- normal_dry_sdiv_log = cpm of dge_data
- sample_names = names of samples with names(dry_sdiv)
- design = matrix of design conditions


## Dry Samples

```{r what samples were "Dry"}
dry_sample <- sample %>%
  filter(condition == "Dry") %>%
  filter(sample != "i02") %>%
  filter(sample != "i03") # had to remove these two samples because dry_sdiv did not have counts for these and it wouldn't let me move on with uneven number of sample sizes
```

- any sample from 01 to 05 was dry

```{r only keep samples 01-05}
dry_sdiv <- sdiv %>%
  select(contains("01") | contains("02") | contains("03") | contains("04") | contains("05")) # would be curious to see how you would've done this part
```

```{r only keep samples 01-05 method #2}
dry_sdiv_jm <- sdiv %>%
  select(matches("0[1-5]"))
```

```{r seeing if samples match between dry_sdiv and dry_sample}
names(dry_sdiv)
dry_sample$sample # is there a way to automatically check if these match? the way i made the dry_sdiv makes it harder to see if they are the same.
```

```{r checking for matching names}
#If we just want to see if the same items are in each:
setequal(names(dry_sdiv), dry_sample$sample)
#TRUE

#or for true equivalency
identical(names(dry_sdiv), dry_sample$sample)
# FALSE!

#Why? not in same order
names(dry_sdiv) == dry_sample$sample
```


- at this point, there are 60 samples

## Normalizing and Plotting

```{r rearranging dry_sdiv names}
dry_sdiv <- dry_sdiv %>% select(sort(colnames(dry_sdiv)))
names(dry_sdiv)
```

```{r calculate normalization factors}
dge_data <- DGEList(counts = dry_sdiv, # lab says this needs to be a matrix, but this worked. also i'm not sure if that changes anything or what the difference would be
                    
# Looks like they updated it so that it can take a data frame

        samples=dry_sample, #Not really needed but I went ahead and added this
        group = dry_sample$group)

dge_data <- calcNormFactors(dge_data, method = "TMM")
dge_data$samples # could've used this too see if the first column and the "sample" column matches
```

```{r plotting dge_data}
plotMDS(dge_data, method = "bcv") # I'm not sure if this was done correctly, most of then are clustered together by condition. (I assume, since it's hard to see with all the over lapping.) But there are a few that seem really spread out, like the j, b, g, m, e, h. Are those the ones that need to be removed? or do I need to plot CPM data to figure out which ones to remove?)
```

^^ remove based on CPM

```{r extracing normalized data}
normal_dry_sdiv <- cpm(dge_data)

normal_dry_sdiv_log <- cpm(dge_data, log = T)
```

# Week 2 and 3

## Things I missed last time, and do I need to go back and do them?
- histogram of dry samples to see if normalization is needed (see "Trying to to Histograms" below)
- lab tells you to retain genes with > 10 reads in >= 3 samples, I did not do this
- doing pairs() or cor() (see "Pairs and Cors" below)

## Trying to do Histograms

```{r storing sample names}
sample_names <- names(dry_sdiv)
```
 
```{r trying for loops in R, eval=FALSE}
for (names in c("a01", "a02")) { 
    g <- ggplot(dry_sdiv, aes(x = names)) +
          geom_histogram() +
          scale_x_log10()
    print(g)
} # I haven't done for loops like this before, so I'm not sure how to do this in a for loop, but the manual way seems long and tedious
```

```{r using ai to make a for loop, eval=FALSE}
# fix the for loop above to output multiple graphs (i used ai to autocomplete the following code and it still doesn't work)
for (i in 1:length(sample_names)) {
  g <- ggplot(dry_sdiv, aes(x = sample_names[i])) +
          geom_histogram() +
          scale_x_log10()
  print(g)
}
```

```{r shiny app instead, eval=FALSE}
ui <- fluidPage(
  
  selectInput("x", "Select Sample", choices = names(dry_sdiv), selected = "a01"),
  hr(),
  plotOutput("plot")
  
)

server <- function(input, output, session) {
  
  output$plot <- renderPlot({
    ggplot(data = dry_sdiv, aes_string(x = input$x)) +
     geom_histogram() +
     scale_x_log10()
  })
  
  session$onSessionEnded(stopApp)
  
}

shinyApp(ui, server)
```

##  Boxplots

```{r boxplots}
boxplot(dry_sdiv)
boxplot(normal_dry_sdiv)
boxplot(normal_dry_sdiv_log) # is this how you want the box plot?
# is this the plot we use to trim out the ones that didn't normalize well? if so, not sure what to look for here.
# in the normal one: there are a couple that still have very high counts
# in the log one: a01 seem the only one that is majorly different. other kinda different ones: g01, l01, k03, c05
```

## Pairs and Cors

```{r doing pairs(), eval=FALSE}
dry_sdiv %>%
  head(1000) %>%
  pairs() # file margins too large 
```

```{r doing cor()}
cor_table <- dry_sdiv %>% select(sort(colnames(.))) %>% cor()
cor_table %>% gplots::heatmap.2(Rowv=FALSE, Colv=FALSE, dendrogram="none", trace = "none", col=viridis::viridis(25, begin=.25), margins=c(7,8))
```

## Calculating Dispersion Factors

- continuing without trimming...

```{r making a design matrix}
design <- model.matrix(~ population, data = dry_sample) # they are all "dry" so I didn't need to do "population + condition" right?
rownames(design) <- dry_sample$sample.description
design
```

```{r estimate dispersion: common}
dge_data <- estimateGLMCommonDisp(dge_data, design, verbose = TRUE)
# Disp = 1.26946 , BCV = 1.1267 
# new values: Disp = 0.58844 , BCV = 0.7671 
```

```{r estimate dispersion: trended}
dge_data <- estimateGLMTrendedDisp(dge_data, design)
```

```{r estimate dispersion: tagwise}
dge_data <- estimateGLMTagwiseDisp(dge_data, design)
```

```{r plotting biological coefficent of variation and average log CPM}
plotBCV(dge_data) # why does trend look like that. shouldn't it start much higher and go down?
```

## Find Differentially Expressed Genes

```{r full model}
fit <- glmFit(dge_data, design)
```

```{r checking coefficient names}
colnames(design[,-1])
```

```{r}
dry_lrt <- glmLRT(fit, coef = colnames(design[,-1])) # nothing overlaps on the matrix so i'm not sure if this does anything. should this be done with all samples, not just dry samples?
```

```{r}
topTags(dry_lrt)
```

```{r}
summary(decideTestsDGE(dry_lrt, p.value=0.01))
```




